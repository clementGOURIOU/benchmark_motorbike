# -*- coding: utf-8 -*-
'''
    File name: residuals.py
    Author:  Gabriel Marcos MagalhÃ£es (UMinho)
    Date created: 05/12/2023
    Python Version: 3.10.12
'''
import os
# Semi-coupled solvers list
SEMI_COUPLED = [ 'semiCoupledViscoelasticFoam']
# Fully-coupled solvers list
FULLY_COUPLED = ['coupledViscoelasticFoam']
# Default prefix of residual files
DEF_RES_FILE = 'residuals.csv'


def get_prop(file, expression, idx=-1):
    """
    Get properties in a file using regex expressions.

    Arguments:
    - file (str): The file path to search for the expression.
    - expression (str): The regex expression for the property.
    - idx (int, optional): The index of the desired occurrence. 
        By default, it returns the last occurrence.

    Returns:
    - str: The value for the expression at the specified index.

    Raises:
    - FileNotFoundError: If the specified file is not found.

    Note:
    This function searches for a specified regex expression in a file 
    and returns the corresponding value. If multiple occurrences are found, 
    you can specify which one to return using the 'idx' parameter.
    """
    import re

    # Ensure the file exists
    try:
        with open(file, "r") as text_file:
            content = text_file.read()
    except FileNotFoundError:
        raise FileNotFoundError(f"File '{file}' not found.")

    # Find all occurrences of the expression in the file content
    results = re.findall(expression, content)

    # If no occurrences found, return None
    if not results:
        return None

    # Return the value at the specified index (default is last occurrence)
    return results[idx]


def get_modes(case):
    """
    Retrieve the modes defined in a viscoelasticProperties file for a given case.

    Parameters:
    - case (str): The name of the case directory containing the viscoelasticProperties file.

    Returns:
    - modes (list): A list containing the modes extracted from the viscoelasticProperties file.

    Note:
    The function extracts modes based on the type of viscoelastic model defined in the file.
    If the type is 'multiMode' or 'multiModeCoupled', it retrieves all modes defined.
    If not, it defaults to a single mode 'M1'.
    """
    import re

    # Construct the path to the viscoelasticProperties file
    file = f'{case}/constant/viscoelasticProperties'

    # Get the type of viscoelastic model defined in the file
    type_model = get_prop(file, r"\s+type\s+(\w+);", idx=0)

    # Define regular expression pattern to extract modes
    exp = r"\s+(\w+)\s*{\s*type\s+\w+;"

    if type_model in ["multiMode", "multiModeCoupled"]:
        # If the type is multiMode or multiModeCoupled, extract all modes
        with open(file, "r") as text_file:
            modes = re.findall(exp, text_file.read())[1:]
    else:
        # Otherwise, default to a single mode 'M1'
        modes = ["M1"]

    return modes


def foam_log(log_file, log_dir, iter2get, generate_file=True, root_case="./"):
    """
    Extracts residuals from OpenFOAM log files based on the solver type and viscoelastic modes.

    Arguments:
    - log_file (str): The path to the log file generated by OpenFOAM.
    - log_dir (str): The directory to store the log files.
    - iter2get (int): The non-linear (PISO) iteration number to extract data for.
    - generate_file (bool): Whether to generate CSV files from the extracted data. 
                            Default is True.
    - root_case (str): The root case directory. 
                        Default is "./".

    Returns:
    - dict: A dictionary containing Pandas dataframes with time, residuals for 
            each variable, and number of iterations.

    Note:
    This function extracts residuals from OpenFOAM log files based on the solver name
    and viscoelastic modes. It determines the solver type and viscoelastic modes, and 
    then calls the appropriate functions to extract residuals.
    """
    d = dict()

    # Get viscoelastic modes
    modes = get_modes(root_case)

    # Get solver name
    solver = get_prop('./system/controlDict', r'\napplication\s+(\w+);')

    # Define variables for velocity-pressure and stress fields
    vars_pu = ['Ux', 'Uy', 'Uz', 'p']
    vars_tau = ['tauXX', 'tauXY', 'tauXZ', 'tauYY', 'tauYZ', 'tauZZ']

    # Extract residuals for velocity-pressure variables
    if solver not in FULLY_COUPLED:
        dpu = pu_log(log_file, log_dir, solver, names=vars_pu,
                     iter2get=iter2get, generate_file=generate_file)
    else:
        # Extract residuals for fully coupled solver with multiple modes
        if len(modes) > 1:
            coupled_mode = get_prop('./constant/viscoelasticProperties',
                                    r'\s*coupledMode\s+(\w+);')
            coupled_vars = vars_pu + \
                [f'{var[:-2]}{coupled_mode}{var[-2:].lower()}' for var in vars_tau]
        else:
            coupled_vars = vars_pu + vars_tau

        dpu = pu_log(log_file, log_dir, solver, names=coupled_vars,
                     iter2get=iter2get, generate_file=generate_file)
        if len(modes) > 1:
            modes.remove(coupled_mode)

    d.update(dpu)

    # Extract residuals for stress variables
    dtau = tau_log(log_dir, names=vars_tau, modes=modes, iter2get=iter2get,
                   solver=solver, output_file=f'{log_dir}/residuals')
    d.update(dtau)

    return d


def pu_log(log_file, log_dir, solver, names, iter2get, generate_file):
    """
    Extracts residuals from OpenFOAM log files based on the solver type.

    Arguments:
    - log_file (str): The path to the log file generated by the solver.
    - log_dir (str): The directory containing the log files.
    - solver (str): The name of the solver used.
    - names (list of str): The variables to extract from the log.
    - iter2get (int): The non-linear (PISO) iteration number to extract data for.
    - generate_file (bool): Whether to generate CSV files from the extracted data.

    Returns:
    - dict: A dictionary containing Pandas dataframes with time, residuals
            for each variable, and number of iterations.

    Note:
    This function extracts residuals from OpenFOAM log files based on the solver type.
    If the solver is semi-coupled or fully coupled, it uses the log_coupled function.
    Otherwise, it uses the log_segregated function. Note that the solver are in the
    global strings SEMI_COUPLED and FULLY_COUPLED
    """
    output_file = f'{log_dir}/residuals'

    if (solver in SEMI_COUPLED) or (solver in FULLY_COUPLED):
        return log_coupled(log_file, names, iter2get, generate_file, output_file=output_file)
    else:
        return log_segregated(log_dir, names, iter2get, generate_file, output_file=output_file)


def log_coupled(log_file, names, iter2get, generate_file=True, output_file=DEF_RES_FILE):
    """
    Extracts the residuals from an OpenFOAM log file for coupled solvers.

    Arguments:
    - log_file (str): The path to the log file generated by the coupled solver.
    - names (list of str): The variables to extract from the log.
    - iter2get (int): The non-linear iteration number to extract data for.

    Optionals:
    - generate_file (bool): Whether to generate CSV files from the extracted data. 
                            Default is True.
    - output_file (str): The name of the CSV file to record the dataframe. 
                         Default is DEF_RES_FILE.

    Returns:
    - dict: A dictionary containing Pandas dataframes with time, residuals 
            for coupled variables, and number of iterations.

    Note:
    This function extracts residuals, time, and number of iterations from an OpenFOAM 
    log file for coupled solvers. It processes the data and returns a dictionary of Pandas 
    dataframes, each dataframe containing information for a specific variable.
    """
    import pandas as pd
    import re

    # Extract the content of log file to log variable as a string
    with open(log_file, "r") as text_file:
        log = text_file.read()

    # Quantities related to coupled solution
    cols = ['InitialRes', 'FinalRes', 'Iter']

    # Regex operations to extract time, residuals, and number of non-linear iterations
    exp = r'Initial residual = \(([\d\.*\d*e*\-*\+*\d*\s]+)\),\s+Final residual = \(([\d\.*\d*e*\-*\+*\d*\s]+)\),\s+No Iterations\s+(\d+)'
    time_exp = re.compile(r'\WTime = (\d+\.*\d*e*\-*\+*\d*)\n')
    nsub_exp = r"nOuterCorrectors\s+(\d+);"

    residuals = re.findall(exp, log)
    ttime = re.findall(time_exp, log)
    nsub = int(get_prop("./system/fvSolution", nsub_exp))

    # Initialization of dictionaries and data frames
    d = dict()
    for key in names:
        d[key] = pd.DataFrame(columns=['Time'] + cols)
    d_sub_iter = dict()

    # Iterate through sub iterations
    for i in range(nsub):
        d_sub_iter[i] = []

    # Build the full dataframe for iter2get
    sub_iter = 0
    for res in residuals:
        line = []
        for i in range(len(res)):
            line.extend([float(j) for j in list(res[i].split(" "))])
        if sub_iter >= nsub:
            sub_iter = 0
        d_sub_iter[sub_iter].append(line)
        sub_iter += 1

    # Construct full dataframe
    dffull_cols = []
    for col in cols[:-1]:
        for name in names:
            dffull_cols.append(f'{name}_{col}')
    dffull_cols.append('Iter')

    dffull = pd.DataFrame(d_sub_iter[iter2get], columns=dffull_cols)
    dffull.insert(loc=0, column='Time', value=[float(i) for i in ttime])

    # Build dataframe for each property from the full dataframe
    d = individual_dataframes(dffull, names, cols, d)

    # Write CSV file for each dataframe
    if generate_file:
        for name in names:
            d[name].to_csv(f'{output_file}_{name}.csv',
                           sep=',', index=False, encoding='utf-8')

    return d


def individual_dataframes(dffull, names, cols, d):
    """
    Split a full dataframe into individual dataframes for each variable.

    Arguments:
    - dffull (DataFrame): The full dataframe containing data for all variables.
    - names (list of str): The variables to extract from the log.
    - cols (list of str): The solution properties to extract from the log.
    - d (dict): The dictionary to insert the individual dataframes.

    Returns:
    - dict: A dictionary containing individual dataframes for each variable.

    Note:
    This function splits a full dataframe into individual dataframes for each variable.
    It assigns time, residuals, and iteration columns from the full dataframe 
    to each individual dataframe.
    """
    # Iterate through variable names
    for name in names:
        # Assign time column from full dataframe to individual dataframe
        d[name]['Time'] = dffull.Time
        # Iterate through residual columns
        for col in cols[:-1]:
            # Assign residual columns from full dataframe to individual dataframe
            d[name][col] = dffull[f'{name}_{col}']
        # Assign iteration column from full dataframe to individual dataframe
        d[name]['Iter'] = dffull.Iter

    return d


def log_segregated(log_dir, names, iter2get, generate_file=True, output_file=DEF_RES_FILE):
    """
    Extracts the residuals from OpenFOAM log files for segregated solvers.

    Arguments:
    - log_dir (str): The directory containing the log files.
    - names (list of str): The variables to extract from the log.
    - iter2get (int): The PISO iteration to extract data for.

    Optionals:
    - generate_file (bool): Whether to generate CSV files from the extracted data. 
                            Default is True.
    - output_file (str): The name of the CSV file to record the dataframe. 
                         Default is DEF_RES_FILE.

    Returns:
    - dict: A dictionary containing Pandas dataframes with time, residuals 
            for each variable, and number of iterations.

    Note:
    This function extracts residuals from OpenFOAM log files for segregated solvers.
    It processes the data and returns a dictionary of Pandas dataframes, each dataframe 
    containing information for a specific variable.
    """
    import pandas as pd

    it = iter2get  # non-linear iteration
    # Quantities related to linear system solutions
    cols = ['InitialRes', 'FinalRes', 'Iters']

    d = dict()

    # Build dataframe for each property
    for key in names:
        d[key] = pd.DataFrame(columns=cols)
        for col in cols:
            file = f'{log_dir}/{key}{col}_{it}'
            if col == 'InitialRes':
                file = f'{log_dir}/{key}_{it}'
            df_aux = pd.read_table(
                file, names=['t', 'prop'], sep='\s+', engine='python')

            d[key][col] = df_aux.prop

    for name in names:
        # Insert time column
        d[name].insert(loc=0, column='Time', value=df_aux.t)
        # Write CSV file for each dataframe
        if generate_file:
            d[name].rename(columns={"Iters": "Iter"}).to_csv(
                f'{output_file}_{name}.csv', sep=',', index=False, encoding='utf-8')

    return d


def segregated_modes_names(solver, names, modes):
    """
    Generate variable names for segregated viscoelastic solver modes.

    Arguments:
    - solver (str): The name of the solver used.
    - names (list of str): The variables to extract from the log.
    - modes (list of str): The modes of the viscoelastic solver.

    Returns:
    - list of str: The modified variable names with modes appended.

    Note:
    This function generates modified variable names with modes appended 
    for segregated solved modes. It adds modes to variables containing 
    'tau' in their names and returns the modified list of names.
    """
    # If there's only one mode and the solver is not fully coupled, set modes to empty string
    if len(modes) == 1 and solver not in FULLY_COUPLED:
        modes = [""]

    add_mode = []

    # Iterate through variable names
    for name in names:
        # Check if the variable name contains 'tau'
        if "tau" in name:
            prop = name
            # Append modes to variable name
            for mode in modes:
                add_mode.append(
                    f'{prop.lower()[:-2]}{mode}{prop.lower()[-2:]}')

    return add_mode


def tau_log(log_dir, names, modes, iter2get, solver, output_file=DEF_RES_FILE, generate_file=True):
    """
    Extracts the tau residuals from OpenFOAM log files for viscoelastic solvers
    for the modes solved segregated.

    Arguments:
    - log_dir (str): The directory containing the log files generated by the solver.
    - names (list of str): The variables to extract from the log.
    - modes (list of str): The modes of the viscoelastic solver.
    - iter2get (int): The non-linear iteration number to extract data for.
    - solver (str): The name of the solver used.

    Optionals:
    - output_file (str): The name of the CSV file to record the dataframe. Default is DEF_RES_FILE.
    - generate_file (bool): Whether to generate CSV files from the extracted data. Default is True.

    Returns:
    - dict: A dictionary containing Pandas dataframes with time, 
            residuals for each variable, and number of iterations.

    Note:
    This function extracts residuals from OpenFOAM log files for viscoelastic solvers.
    It processes the data and returns a dictionary of Pandas dataframes, each dataframe 
    containing information for a specific variable.
    """
    import pandas as pd

    cols = ['InitialRes', 'FinalRes', 'Iters']

    d = dict()

    # Check if segregated modes are defined
    if len(modes) == 0:
        return d
    else:
        # Prepare names based on solver type and modes
        names = segregated_modes_names(solver, names, modes)

    # Iterate through each property
    for key in names:
        d[key] = pd.DataFrame(columns=cols)

    # Extract residuals for each property
    for prop in names:
        for col in cols:
            res_file = f'{log_dir}/{prop}{col}_{iter2get}'
            if col == 'InitialRes':
                res_file = f'{log_dir}/{prop}_{iter2get}'
            df = pd.read_table(
                res_file, names=['Time', 'prop'], sep='\s+', engine='python')
            d[prop][col] = df.prop
        d[prop].insert(loc=0, column='Time', value=[float(i) for i in df.Time])
        d[prop] = d[prop].rename(columns={"Iters": "Iter"})
        if generate_file:
            d[prop].to_csv(f'{output_file}_{prop}.csv',
                           sep=',', index=False, encoding='utf-8')

    return d

def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Extracts residuals from OpenFOAM log files based on the solver type and viscoelastic modes.")
    parser.add_argument("-l","--log", type=str, dest="logFile", required=True,
                        help="Solver log file to extract the contents.")
    parser.add_argument("-i","--iter", type=int, dest="iter", required=False,
                        help="Non-linear (PISO) iteration to get the data.")
    parser.add_argument("-d","--logDir", type=str, dest="logDir", required=False,
                        help="The directory to store the log files.")
    args = parser.parse_args()

    # Set default log directory
    log_dir = "./logs"
    if args.logDir:
        log_dir = args.logDir
    # Create log directory if it doesn't exist
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)

    # Set default iteration to 0 if not provided
    iter2get = args.iter if args.iter else 0

    # Extract residuals from log file
    foam_log(args.logFile, log_dir, iter2get)


if __name__ == "__main__":
    main()
